<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Solar System + Milky Way + IAU Constellations</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
#ui{
  position:fixed;top:14px;left:14px;z-index:10;
  color:#fff;font-family:system-ui;
  background:rgba(0,0,0,.45);
  padding:12px;border-radius:10px;
}
button{width:220px;margin-top:6px}
canvas{display:block}
</style>
</head>
<body>

<div id="ui">
  <button id="toggleConst">Toggle Constellations</button>
</div>

<video id="cam" autoplay playsinline style="display:none"></video>

<!-- âœ… HIPPARCOS DATA (CLASSIC SCRIPT, SAFE) -->
<script src="./hipparcos_6.5_concise.js" defer></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js";

/* ================= WAIT FOR HIPPARCOS ================= */
async function waitForHipparcos(){
  while(!window.hipparcos_6_5){
    await new Promise(r=>setTimeout(r,20));
  }
}

/* ================= BASIC ================= */
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x000005);

const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,8000);
camera.position.set(0,30,220);

const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;

scene.add(new THREE.AmbientLight(0x222233,0.6));

/* ================= ROOT ================= */
const galaxyRoot=new THREE.Group();
scene.add(galaxyRoot);

/* ================= HELPERS ================= */
function raDecToVec3(raDeg, decDeg, r=1200){
  const ra=THREE.MathUtils.degToRad(raDeg);
  const dec=THREE.MathUtils.degToRad(decDeg);
  return new THREE.Vector3(
    r*Math.cos(dec)*Math.cos(ra),
    r*Math.sin(dec),
    r*Math.cos(dec)*Math.sin(ra)
  );
}

/* ===================== STARS ===================== */
const starMap={};

async function loadStars(){
  await waitForHipparcos();
  const stars=window.hipparcos_6_5;

  const pos=[], col=[];
  stars.forEach(s=>{
    starMap["HIP"+s.HIP]=s;

    const v=raDecToVec3(s.RAdeg,s.DEdeg);
    pos.push(v.x,v.y,v.z);

    const b=Math.max(0.2,1.6-s.Vmag*0.35);
    col.push(b,b,b);
  });

  const g=new THREE.BufferGeometry();
  g.setAttribute("position",new THREE.Float32BufferAttribute(pos,3));
  g.setAttribute("color",new THREE.Float32BufferAttribute(col,3));

  galaxyRoot.add(new THREE.Points(
    g,
    new THREE.PointsMaterial({
      size:1.3,
      vertexColors:true,
      transparent:true,
      depthWrite:false
    })
  ));
}

/* ================= CONSTELLATIONS ================= */
let constellationLines;

async function loadConstellations(){
  const data=await fetch("./constellations_iau.json").then(r=>r.json());

  const pts=[];
  data.constellations.forEach(c=>{
    c.lines.forEach(([a,b])=>{
      const s1=starMap[a];
      const s2=starMap[b];
      if(!s1||!s2)return;

      const v1=raDecToVec3(s1.RAdeg,s1.DEdeg,1190);
      const v2=raDecToVec3(s2.RAdeg,s2.DEdeg,1190);
      pts.push(v1.x,v1.y,v1.z,v2.x,v2.y,v2.z);
    });
  });

  constellationLines=new THREE.LineSegments(
    new THREE.BufferGeometry().setAttribute(
      "position",new THREE.Float32BufferAttribute(pts,3)
    ),
    new THREE.LineBasicMaterial({
      color:0x66ccff,
      transparent:true,
      opacity:0.6
    })
  );
  galaxyRoot.add(constellationLines);
}

toggleConst.onclick=()=>constellationLines.visible=!constellationLines.visible;

/* ================= START ================= */
await loadStars();
await loadConstellations();

/* ================= ANIMATE ================= */
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
