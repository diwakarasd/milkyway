<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Milky Way — Cinematic (Refined)</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
#ui{
  position:fixed;left:16px;top:16px;z-index:10;
  background:rgba(0,0,0,.5);
  color:#fff;padding:12px 14px;
  border-radius:10px;font-family:system-ui;font-size:13px;
}
canvas{display:block}
</style>
</head>
<body>

<div id="ui">
<b>Milky Way — Cinematic</b><br>
Scroll = Zoom · Drag = Rotate
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "post": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/UnrealBloomPass.js";

/* ================= BASIC ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020208);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 20000);
camera.position.set(0, 220, 1400);

/* ================= CONTROLS ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = true;
controls.zoomSpeed = 1.2;
controls.minDistance = 200;
controls.maxDistance = 6000;
controls.enablePan = false;

/* ================= POST ================= */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(
  new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    0.6, 0.4, 0.75
  )
);

/* ================= ROOT ================= */
const galaxyRoot = new THREE.Group();
scene.add(galaxyRoot);

/* ================= TEXTURES ================= */
const tl = new THREE.TextureLoader();
const starTex =
  tl.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/disc.png");
const smokeTex =
  tl.load("https://diwakarasd.github.io/galaxy-textures/smoke.png");

/* ================= REALISTIC SCATTERED MILKY WAY ================= */
function createMilkyWay() {
  const stars = 30000;
  const pos = [];
  const col = [];

  for (let i = 0; i < stars; i++) {
    const isArm = Math.random() < 0.65; // rest are scattered / halo
    const radius = Math.pow(Math.random(), 0.45) * 3000;

    let angle;
    if (isArm) {
      const arm = Math.floor(Math.random() * 4);
      angle =
        radius * 0.003 +
        arm * (Math.PI * 2 / 4) +
        (Math.random() - 0.5) * 0.45; // blur arm
    } else {
      angle = Math.random() * Math.PI * 2;
    }

    // scatter strength increases with radius
    const scatter = (1 - Math.exp(-radius / 1200)) * 220;

    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * scatter;
    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * scatter;
    const y =
      (Math.random() - 0.5) *
      (120 + Math.random() * 160) *
      Math.exp(-radius / 1600);

    pos.push(x, y, z);

    const c = new THREE.Color();
    c.setHSL(
      0.58 + radius / 5200,
      0.55 + Math.random() * 0.2,
      0.65 + Math.random() * 0.1
    );
    col.push(c.r, c.g, c.b);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
  geo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));

  const mat = new THREE.PointsMaterial({
    size: 1.2,
    map: starTex,
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  galaxyRoot.add(new THREE.Points(geo, mat));
}
createMilkyWay();

/* ================= LIGHT NEBULA (REDUCED DENSITY) ================= */
for (let i = 0; i < 90; i++) {
  const sprite = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: smokeTex,
      color: new THREE.Color().setHSL(
        0.6 + Math.random() * 0.2,
        0.6,
        0.5
      ),
      transparent: true,
      opacity: 0.07,
      depthWrite: false
    })
  );

  const r = 600 + Math.random() * 2600;
  const a = Math.random() * Math.PI * 2;
  sprite.position.set(
    Math.cos(a) * r,
    (Math.random() - 0.5) * 300,
    Math.sin(a) * r
  );

  const s = 900 + Math.random() * 1200;
  sprite.scale.set(s, s, 1);
  galaxyRoot.add(sprite);
}

/* ================= SOLAR SYSTEM ================= */
const solar = new THREE.Group();
solar.position.set(1100, 0, 400);
galaxyRoot.add(solar);

const sun = new THREE.Mesh(
  new THREE.SphereGeometry(14, 48, 32),
  new THREE.MeshBasicMaterial({
    map: tl.load("https://diwakarasd.github.io/galaxy-textures/2k_sun.jpg")
  })
);
solar.add(sun);

const sunGlow = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: starTex,
    color: 0xffcc88,
    opacity: 0.25,
    blending: THREE.AdditiveBlending
  })
);
sunGlow.scale.set(70, 70, 1);
sun.add(sunGlow);

/* ================= PLANETS ================= */
const planets = [];
function planet(size, dist, speed, tex, ring=false) {
  const pivot = new THREE.Object3D();
  solar.add(pivot);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size, 32, 32),
    new THREE.MeshBasicMaterial({ map: tex })
  );
  pivot.add(mesh);

  if (ring) {
    const ringMesh = new THREE.Mesh(
      new THREE.RingGeometry(size * 1.4, size * 2.6, 64),
      new THREE.MeshBasicMaterial({
        map: tl.load("https://diwakarasd.github.io/galaxy-textures/2k_saturn_ring_alpha.png"),
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      })
    );
    ringMesh.rotation.x = Math.PI / 2 - 0.35;
    mesh.add(ringMesh);
  }

  planets.push({ pivot, mesh, dist, speed, a: Math.random() * Math.PI * 2 });
}

planet(2, 30, 0.014, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_mercury.jpg"));
planet(3.5, 42, 0.012, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_venus_surface.jpg"));
planet(3.8, 56, 0.01, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_earth_daymap.jpg"));
planet(2.4, 72, 0.008, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_mars.jpg"));
planet(7, 96, 0.004, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_jupiter.jpg"));
planet(6.2, 126, 0.003, tl.load("https://diwakarasd.github.io/galaxy-textures/2k_saturn.jpg"), true);

/* ================= ANIMATION ================= */
function animate() {
  requestAnimationFrame(animate);

  planets.forEach(p => {
    p.a += p.speed;
    p.mesh.position.set(
      Math.cos(p.a) * p.dist,
      0,
      Math.sin(p.a) * p.dist
    );
  });

  galaxyRoot.rotation.y += 0.0001;

  controls.update();
  composer.render();
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
