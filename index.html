<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Milky Way — Cinematic</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
#ui{
  position:fixed;left:16px;top:16px;z-index:10;
  background:rgba(0,0,0,.55);
  color:#fff;padding:12px 14px;
  border-radius:10px;
  font-family:system-ui;font-size:13px;
}
canvas{display:block}
</style>
</head>
<body>

<div id="ui">
<b>Milky Way — Cinematic</b><br>
Scroll = Zoom · Drag = Rotate<br>
Arrow keys = Move (strafe & forward)
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js";

/* ================= BASIC ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020208);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 20000);
camera.position.set(0, 300, 1500);

/* ================= CONTROLS ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.zoomSpeed = 1.2;
controls.minDistance = 300;
controls.maxDistance = 8000;

/* ================= ROOT ================= */
const galaxy = new THREE.Group();
scene.add(galaxy);

/* ================= TEXTURES ================= */
const loader = new THREE.TextureLoader();
const starTex = loader.load(
  "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/disc.png"
);
const smokeTex = loader.load(
  "https://diwakarasd.github.io/galaxy-textures/smoke.png"
);

/* ================= SPIRAL GALAXY (UNCHANGED LOGIC) ================= */
function createGalaxy() {
  const arms = 2;
  const count = 36000;
  const pos = [];
  const col = [];

  for (let i = 0; i < count; i++) {
    const r = Math.pow(Math.random(), 0.42) * 3200;
    const arm = Math.floor(Math.random() * arms);

    let angle =
      r * 0.0028 +
      arm * (Math.PI * 2 / arms) +
      (Math.random() - 0.5) * 1.1;

    if (Math.random() < 0.35) {
      angle += (Math.random() - 0.5) * 2.4;
    }

    const spread = (1 - Math.exp(-r / 1100)) * 380;

    const x = Math.cos(angle) * r + (Math.random() - 0.5) * spread;
    const z = Math.sin(angle) * r + (Math.random() - 0.5) * spread;
    const y =
      (Math.random() - 0.5) *
      (180 + Math.random() * 260) *
      Math.exp(-r / 1800);

    pos.push(x, y, z);

    const c = new THREE.Color();
    c.setHSL(
      0.55 + r / 6000,
      0.55 + Math.random() * 0.2,
      0.6 + Math.random() * 0.15
    );
    col.push(c.r, c.g, c.b);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
  geo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));

  const mat = new THREE.PointsMaterial({
    size: 1.25,
    map: starTex,
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  galaxy.add(new THREE.Points(geo, mat));
}
createGalaxy();

/* ================= NEBULA (COLOR UNCHANGED) ================= */
for (let i = 0; i < 70; i++) {
  const s = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: smokeTex,
      color: new THREE.Color().setHSL(0.62, 0.5, 0.45),
      opacity: 0.05,
      transparent: true,
      depthWrite: false
    })
  );
  const r = 800 + Math.random() * 2600;
  const a = Math.random() * Math.PI * 2;
  s.position.set(
    Math.cos(a) * r,
    (Math.random() - 0.5) * 300,
    Math.sin(a) * r
  );
  const scale = 1000 + Math.random() * 1400;
  s.scale.set(scale, scale, 1);
  galaxy.add(s);
}

/* ================= GALACTIC CENTER (WHITE, FEATHERED ONLY) ================= */
const coreGroup = new THREE.Group();
galaxy.add(coreGroup);

// bright core
const core = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: starTex,
    color: 0xffffff,
    opacity: 0.85,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  })
);
core.scale.set(520, 480, 1);
coreGroup.add(core);

// irregular feather
for (let i = 0; i < 4; i++) {
  const halo = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: smokeTex,
      color: 0xffffff,
      opacity: 0.12 / (i + 1),
      transparent: true,
      depthWrite: false
    })
  );
  halo.scale.set(800 + i * 450, 620 + i * 380, 1);
  halo.rotation.z = Math.random();
  coreGroup.add(halo);
}

/* ================= SOLAR SYSTEM (UNCHANGED) ================= */
const solar = new THREE.Group();
solar.position.set(1100, 0, 400);
galaxy.add(solar);

const sun = new THREE.Mesh(
  new THREE.SphereGeometry(14, 48, 32),
  new THREE.MeshBasicMaterial({
    map: loader.load("https://diwakarasd.github.io/galaxy-textures/2k_sun.jpg")
  })
);
solar.add(sun);

const sunGlow = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: starTex,
    color: 0xffcc88,
    opacity: 0.25,
    blending: THREE.AdditiveBlending
  })
);
sunGlow.scale.set(70, 70, 1);
sun.add(sunGlow);

/* ================= PLANETS ================= */
const planets = [];
function planet(size, dist, speed, tex, ring=false) {
  const pivot = new THREE.Object3D();
  solar.add(pivot);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size, 32, 32),
    new THREE.MeshBasicMaterial({ map: tex })
  );
  pivot.add(mesh);

  if (ring) {
    const ringMesh = new THREE.Mesh(
      new THREE.RingGeometry(size * 1.4, size * 2.6, 64),
      new THREE.MeshBasicMaterial({
        map: loader.load("https://diwakarasd.github.io/galaxy-textures/2k_saturn_ring_alpha.png"),
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      })
    );
    ringMesh.rotation.x = Math.PI / 2 - 0.35;
    mesh.add(ringMesh);
  }

  planets.push({ mesh, dist, speed, a: Math.random() * Math.PI * 2 });
}

planet(2, 30, 0.014, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_mercury.jpg"));
planet(3.5, 42, 0.012, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_venus_surface.jpg"));
planet(3.8, 56, 0.01, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_earth_daymap.jpg"));
planet(2.4, 72, 0.008, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_mars.jpg"));
planet(7, 96, 0.004, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_jupiter.jpg"));
planet(6.2, 126, 0.003, loader.load("https://diwakarasd.github.io/galaxy-textures/2k_saturn.jpg"), true);

/* ================= CAMERA TRANSLATION (FIXED) ================= */
const move = { l:false, r:false, f:false, b:false };

addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") move.l = true;
  if (e.key === "ArrowRight") move.r = true;
  if (e.key === "ArrowUp") move.f = true;
  if (e.key === "ArrowDown") move.b = true;
});

addEventListener("keyup", e => {
  if (e.key === "ArrowLeft") move.l = false;
  if (e.key === "ArrowRight") move.r = false;
  if (e.key === "ArrowUp") move.f = false;
  if (e.key === "ArrowDown") move.b = false;
});

/* ================= ANIMATE ================= */
function animate() {
  requestAnimationFrame(animate);

  planets.forEach(p => {
    p.a += p.speed;
    p.mesh.position.set(
      Math.cos(p.a) * p.dist,
      0,
      Math.sin(p.a) * p.dist
    );
  });

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  dir.y = 0;
  dir.normalize();

  const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
  const speed = 6;

  if (move.f) camera.position.addScaledVector(dir, speed);
  if (move.b) camera.position.addScaledVector(dir, -speed);
  if (move.l) camera.position.addScaledVector(right, -speed);
  if (move.r) camera.position.addScaledVector(right, speed);

  galaxy.rotation.y += 0.00006;

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
