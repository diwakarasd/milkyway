<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Milky Way — Cinematic Realism</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
#ui{
  position:fixed;left:16px;top:16px;z-index:10;
  background:rgba(0,0,0,.55);
  color:#fff;padding:12px 14px;
  border-radius:10px;
  font-family:system-ui;font-size:13px;
}
canvas{display:block}
</style>
</head>
<body>

<div id="ui">
<b>Milky Way — Cinematic</b><br>
Diffuse spiral · Bright galactic core<br>
Scroll = Zoom · Drag = Rotate<br>
Arrow keys = Move · W/S = Up/Down
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js";

/* ================= BASIC ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020208);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 20000);
camera.position.set(0, 300, 1500);

/* ================= CONTROLS ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.zoomSpeed = 1.2;
controls.minDistance = 300;
controls.maxDistance = 8000;

/* ================= ROOT ================= */
const galaxy = new THREE.Group();
scene.add(galaxy);

/* ================= TEXTURES ================= */
const loader = new THREE.TextureLoader();
const starTex = loader.load(
  "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/disc.png"
);
const smokeTex = loader.load(
  "https://diwakarasd.github.io/galaxy-textures/smoke.png"
);

/* ================= REALISTIC DISPERSED SPIRAL ================= */
function createGalaxy() {
  const arms = 2;
  const count = 36000;
  const pos = [];
  const col = [];

  for (let i = 0; i < count; i++) {
    const r = Math.pow(Math.random(), 0.42) * 3200;
    const arm = Math.floor(Math.random() * arms);

    let angle =
      r * 0.0028 +
      arm * (Math.PI * 2 / arms) +
      (Math.random() - 0.5) * 1.1; // BREAK PERFECT SPIRAL

    // leak stars between arms
    if (Math.random() < 0.35) {
      angle += (Math.random() - 0.5) * 2.4;
    }

    const spread = (1 - Math.exp(-r / 1100)) * 380;

    const x = Math.cos(angle) * r + (Math.random() - 0.5) * spread;
    const z = Math.sin(angle) * r + (Math.random() - 0.5) * spread;
    const y =
      (Math.random() - 0.5) *
      (180 + Math.random() * 260) *
      Math.exp(-r / 1800);

    pos.push(x, y, z);

    const c = new THREE.Color();
    c.setHSL(
      0.55 + r / 6000,
      0.55 + Math.random() * 0.2,
      0.6 + Math.random() * 0.15
    );
    col.push(c.r, c.g, c.b);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
  geo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));

  const mat = new THREE.PointsMaterial({
    size: 1.25,
    map: starTex,
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  galaxy.add(new THREE.Points(geo, mat));
}
createGalaxy();

/* ================= RANDOM OUTER STARS ================= */
function createOuterStars(count = 6000) {
  const pos = [];
  for (let i = 0; i < count; i++) {
    const r = 4000 + Math.random() * 6000;
    const a = Math.random() * Math.PI * 2;
    pos.push(
      Math.cos(a) * r,
      (Math.random() - 0.5) * 4000,
      Math.sin(a) * r
    );
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 1.0,
    map: starTex,
    color: 0xffffff,
    transparent: true,
    opacity: 0.45,
    depthWrite: false
  });

  galaxy.add(new THREE.Points(geo, mat));
}
createOuterStars();

/* ================= LIGHT NEBULA ================= */
for (let i = 0; i < 70; i++) {
  const s = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: smokeTex,
      color: new THREE.Color().setHSL(0.62, 0.5, 0.45),
      opacity: 0.05,
      transparent: true,
      depthWrite: false
    })
  );
  const r = 800 + Math.random() * 2600;
  const a = Math.random() * Math.PI * 2;
  s.position.set(
    Math.cos(a) * r,
    (Math.random() - 0.5) * 300,
    Math.sin(a) * r
  );
  const scale = 1000 + Math.random() * 1400;
  s.scale.set(scale, scale, 1);
  galaxy.add(s);
}

/* ================= GALACTIC CENTER (WHITE CORE) ================= */
const core = new THREE.Sprite(
  new THREE.SpriteMaterial({
    map: starTex,
    color: 0xffffff,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  })
);
core.scale.set(600, 600, 1);
galaxy.add(core);

for (let i = 0; i < 3; i++) {
  const halo = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: starTex,
      color: 0xfff6e0,
      opacity: 0.25 / (i + 1),
      blending: THREE.AdditiveBlending,
      depthWrite: false
    })
  );
  const s = 900 + i * 700;
  halo.scale.set(s, s, 1);
  galaxy.add(halo);
}

/* ================= KEYBOARD MOVEMENT ================= */
const move = { x:0, y:0, z:0 };
addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") move.x = -1;
  if (e.key === "ArrowRight") move.x = 1;
  if (e.key === "ArrowUp") move.z = -1;
  if (e.key === "ArrowDown") move.z = 1;
  if (e.key === "w") move.y = 1;
  if (e.key === "s") move.y = -1;
});
addEventListener("keyup", () => {
  move.x = move.y = move.z = 0;
});

/* ================= ANIMATE ================= */
function animate() {
  requestAnimationFrame(animate);

  galaxy.rotation.y += 0.00006;

  camera.position.x += move.x * 6;
  camera.position.y += move.y * 6;
  camera.position.z += move.z * 6;

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
